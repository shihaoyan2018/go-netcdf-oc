# 这是推翻上次编译的学到的结果以及产生新的结论。
##  发现问题
在游戏本编译成功但是在surface go 上编译不成功，并且发现无论如何更改文件位置以及文件名称都无法成功链接，并且在mingw/gcc上无法发现so文件。
在游戏本进行go clean清空缓存后，使用上次产生的的结果无法成功复现。
##  反思问题
由于so库必定调用linux的api尽管做过推断“会使用内部api转换”，但是结合这几次失败看起来应该推断是错误的。
## 解决思路
win下三大c/c++编译整体环境为 vs ， msys/mingw  ， cygwin  。其中vs是直接底层调用winapi，而msys/mingw和cygwin都是模拟linux后调用类似推断，但是仍有部分不同。
所以如果使用什么编译器，相对应的库也应是该编译器编译的是最合适的，所以提出解决思路：重新编译。
解决思路：尝试继续使用so库。
发现之前做过的备份。解决思路：直接调用dll，类似静态编译调用dll的方式，把dll编译入程序。

![](jpg/rm2.JPG)

## 解决方案
重新编译使用cmake，修改一些东西就行，但是仍然很麻烦，否决。
继续使用so库是不行的，否决。
直接调用dll，发现在源码那里编译缺少dll，移动过去发现成功。在测试程序中，发现仍然缺少dll，移动过去发现成功。成功。选择使用此方法。得出结论：c的dll库考虑混用，直接调用编译就行，但是是采用作为源程序的方式，静态编译调用。直接采用源程序的方式调用，gcc默认的路径选为go源码/c源码所在位置。
## 得出结论
直接调用dll合适，但是需要注意：c的dll库考虑混用，直接调用编译就行，但是是采用作为源程序的方式，静态编译调用。直接采用源程序的方式调用，gcc默认的路径选为go源码/c源码所在位置。
## 方案原因
c的链接方式分为两种 lib(静态库)/a 静态编译 允许混用  lib(动态库入口)无法混用或者混用较为困难  dll(单独动态库)/so 动态编译 允许混用 但是dll调用以源程序方式不是作为库方式，并且是静态编译调用。c++的链接方式也分为两种 同 同 不同(dll无法混用，因为会产生很多额外解释，和so不同)。
## 吸取教训
产生错误正常，但是一定要正确认识错误并且改正，不要一条路。
还得学习cmake一类的东西。
要灵活，不要一条路。
不要懒惰。
不要懒惰。
不要懒惰。
要大胆尝试。
但是一定要做备份。
要做备份，并且要使用备份。
