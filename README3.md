##   本文是关于go，cgo，和c/c++引入外部包或者调用外部库的不同。

###   go的引入外部包或者调用外部库

直接输入包地址`import  "..."`在这里需要注意的一点是，在引入三方包时，在`$GOPATH`路径中的`src`文件夹中的相对路径。并且一般不加参数的编译选择重新使用`src`中的源代码进行重新编译，而不是采用`$GOPATH`路径中的`pkg`已编译的二进制包。但是在引入go自带包时，还不确定是使用的`GOROOT`中的`src`源代码，还是`pkg`的已编译的二进制包。

还有就是网络上的包，先在代码中输入`import  "..."`,然后在编译前使用`go get "..."`获取网络上的包，但是此处注意，其实这个步骤根本上就是`go get `先下载包，然后按照路径解包并且编译，并且在后来编译时应该是使用的包的源码。`go get` 就是先`git`下来包（或者采用不同的方式下载包）然后使用`go install`安装这个包。所以`go get`是依赖`git`的。

### cgo的引入外部包或者调用外部库

cgo现在暂时还只允许c语言的调用（据说要加入c++的支持），所以cgo的引入外部包或者调用外部库就是c的引入外部包或者调用外部库，但是仍然存在部分不同。

cgo的引入c的外部包或者调用外部库是在import "C"之前的注释中引入，并且在注释中还允许更改gcc的编译选项（cgo默认的c编译器为gcc）。通常// #include "..h"或者// #include "..c"来引入头文件或者函数实现的源文件，并且通过// #cgo LDFLAGS: ... 更改gcc编译中的链接选项，此处的选项就为直接添加在gcc命令后的选项，比如-I（大写i）用于指定额外include的文件夹位置，-l（小写l）用于指定链接动态库或者静态库名称（在win中由于gcc为模拟linux进行，所以一般链接静态a库或者lib库没问题，但是链接动态库时有问题，在win下不允许链接so库，所以链接动态dll库时直接把dll库放入源码位置，然后直接输入dll库名称，相当于把dll库看作源码文件，静态编译进程序中，但是在linux中正常，链接so或者a库没问题，但是优先链接so库，但是在编译后的程序运行时一般要求环境变量中或者程序发现的位置中有so库，否则无法运行，指定优先链接动态库是 -share，指定优先链接静态库是 -static ）-L（大写l）用于指定动态库或者静态库的文件夹位置。通过// #cgo pkg-config: ... 指定pkg-config的参数以及获取哪个.pc文件。

cgo如果要进行指针的传递必须要引入unsafe包import "unsafe" 。

### c/c++的引入外部包或者调用外部库的不同。

##### c的引入外部包或者调用外部库的不同。

直接#include "..c"以及#include "..h"。直接把函数实现的源文件加入源码中。

给出了静态库，先使用#include "..h"引入函数声明，然后在编译时使用-l指定链接的静态库。vs直接更改就行

给出了动态库，先使用#include "..h"引入函数声明，然后在编译时使用-l指定链接的动态库。vs直接更改就行。但是在使用gcc在win下进行时要使用把dll当作源文件的方法进行编译（原因：在win中由于gcc为模拟linux进行，所以一般链接静态a库或者lib库没问题，但是链接动态库时有问题，在win下不允许链接so库，所以链接动态dll库时直接把dll库放入源码位置，然后直接输入dll库名称，相当于把dll库看作源码文件，静态编译进程序中）。

拓展：-I（大写i）用于指定额外include的文件夹位置，-l（小写l）用于指定链接动态库或者静态库名称（在win中由于gcc为模拟linux进行，所以一般链接静态a库或者lib库没问题，但是链接动态库时有问题，在win下不允许链接so库，所以链接动态dll库时直接把dll库放入源码位置，然后直接输入dll库名称，相当于把dll库看作源码文件，静态编译进程序中，但是在linux中正常，链接so或者a库没问题，但是优先链接so库，但是在编译后的程序运行时一般要求环境变量中或者程序发现的位置中有so库，否则无法运行，指定优先链接动态库是 -share，指定优先链接静态库是 -static ）-L（大写l）用于指定动态库或者静态库的文件夹位置。

##### c++的引入外部包或者调用外部库的不同。

大致同c的引入外部包或者调用外部库相同。

直接#include "..c"以及#include "..h"。直接把函数实现的源文件加入源码中。

给出了静态库，先使用#include "..h"引入函数声明，然后在编译时使用-l指定链接的静态库。vs直接更改就行

给出了动态库，先使用#include "..h"引入函数声明，然后在编译时使用-l指定链接的动态库。vs直接更改就行。但是在使用gcc在win下进行时要使用把dll当作源文件的方法进行编译（原因：在win中由于gcc为模拟linux进行，所以一般链接静态a库或者lib库没问题，但是链接动态库时有问题，在win下不允许链接so库，所以链接动态dll库时直接把dll库放入源码位置，然后直接输入dll库名称，相当于把dll库看作源码文件，静态编译进程序中）。

拓展：-I（大写i）用于指定额外include的文件夹位置，-l（小写l）用于指定链接动态库或者静态库名称（在win中由于gcc为模拟linux进行，所以一般链接静态a库或者lib库没问题，但是链接动态库时有问题，在win下不允许链接so库，所以链接动态dll库时直接把dll库放入源码位置，然后直接输入dll库名称，相当于把dll库看作源码文件，静态编译进程序中，但是在linux中正常，链接so或者a库没问题，但是优先链接so库，但是在编译后的程序运行时一般要求环境变量中或者程序发现的位置中有so库，否则无法运行，指定优先链接动态库是 -share，指定优先链接静态库是 -static ）-L（大写l）用于指定动态库或者静态库的文件夹位置。

**但是，注意：**

在win下魔改使用vs编译产生的静态库（lib）以及动态库（lib和dll）时，**静态库**(lib)通过一定方式进行解开更改后转换成a库在c/c++是没有问题的，但是**动态库**（lib和dll）在**c++**下魔改用lib或者dll导出函数声明在生成符合gcc的a或者lib是不行的，原因是：c++的dll会产生很多不同的声明字段，并且lib动态库入口和dll动态库分开是在以linux模拟实现的gcc不存在的。**动态库（lib和dll）**在**c**下魔改用lib或者dll导出函数声明在生成符合gcc的a或者lib也是不行的，原因是：lib动态库入口和dll动态库分开是在以linux模拟实现的gcc不存在的。
