## 关于c与c++的动态库的问题，再进行的研究。

### 起因

由于看到了syscall的调用c的dll库的原因，所以想尝试调用c++库，使用包装的手段，extern “C”的方法进行，出现了部分问题，尤其是在cgo方面（由于看到了syscall调用c的dll，也通过包装使得c++库得以实现，所以尝试看看cgo是不是允许使用这种方法来使用c++库），所以进行了研究。

### 原因

1、c的dll的abi是通用的，但是c++由于函数重载的原因，每个不同的编译器针对dll中的函数命名问题出现不同，在处理上会出现问题，也就是说c++的dll的每种不同的编译器的abi是不同的。这样就导致了c++的dll无法进行混用，所以需要把c++的dll通过extern “C”的方式来包装成c的dll，这样就使得每种不同的编译器甚至不同的语言进行调用得到实现。
2、cgo的c++还是有问题，即使是使用了extern “C”的方式包装c++的dll，通过c的方式来暴露出函数指针与函数名，也会出现错误。
3、__stdcall,以及__de...(export)的每种方式有些许不同。

### 结论

1、最主要的是，不管怎么样，应当放在实现上，就是说重点在于结果的生成，也就是说一定要搞清楚要的是什么，情况是什么，选择合适的方式，一定要提高开发效率。
2、喜欢的和什么所谓的信念有时候需要更新。
3、c的abi通用，c++不通用，c++的dll需要使用c进行包装，使用extern “C”就行，注意使用__stdcall(在int后），extern “C”在最前面，注意使用_declspec(dllexport)来进行修饰，在extern “C”的后面，也就是说需要`extern "C" __declspec(dllexport) int __stdcall hanshuming();`的声明方式，至于实现就直接  `int hanshuming(){};`就行了。def文件有时候需要有时候不需要，一般是不需要的。在调用的时候，vs直接用原头文件，gcc需要去掉__declspec(dllexport),但是千万不要去掉extern "C",因为去掉了extern "C"，编译器就不认为这个是c的不使用过c的abi寻找函数名以及函数指针了（尽管是链接的时候的需要，但是一开始导出的时候也是链接的需要，也是直接用的这个，应该是内部有参数传递。），似乎vs的__declspec(dllimport)也不太需要，这不是重点。这种方式导出的c的dll都通用，但是cgo存在问题，应该是其固有的问题，所以不需要注意，go的话就是c就用cgo，大的c++就用swig，小的就用c包装后使用syscall（但是go的syscall不够完善，所以如果参数多就需要数组的方式，由于是小的是自己写的包装，所以说用数组的方式完全没问题。）。一定要分析现有情况以及要的是什么，如果是c的go就是cgo，其余的就用syscall（也没有cgo这样的工具），大的c++就用swig，go行，似乎其余的也行，小的c++就用extern “C”包装成c的dll，然后用syscall，go的也是，因为cgo有问题，其余的更是用syscall（因为没有cgo这样的工具），不过go的syscall不太行尤其是多参数。不得不说，go的cgo和syscall都有缺陷，还是半成品，还是纯go坑少，但是太麻烦，太从底层出发，和开发效率高相冲突，所以go还真是个半成品。__stdcall只有win上有，因为需要win的dll的c的api的调用和abi一致，所以如果需要win下的syscall，尽量使用这个，__cdecl是c/c++默认的调用方式，不写就是这个，win下syscall尽量别用，但是linux下的随便，因为linux下没有__stdcall，__fastcall是较快的调用方式，原因不重要，syscall尽量别用win和linux都这样，，cgo不考虑这些，因为这些都是c包装的内容，而cgo由于内在的固有问题不用这些，而syscall的话在win下使用__stdcall,在linux下默认或者__cdecl就行，因为linux下没有__stdcall，无论是哪个都不用__fastcall。
拓展：
##### C语言编译器函数名称修饰规则
          1、__stdcall：编译后，函数名被修饰为“_functionname@number”。
          2、__cdecl：编译后，函数名被修饰为“_functionname”。
          3、__fastcall：编译后，函数名给修饰为“@functionname@nmuber”。
      注：“functionname”为函数名，“number”为参数字节数。
      注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。
##### C++语言编译器函数名称修饰规则
          1、__stdcall：编译后，函数名被修饰为“?functionname@@YG******@Z”。
          2、__cdecl：编译后，函数名被修饰为“?functionname@@YA******@Z”。
          3、__fastcall：编译后，函数名被修饰为“?functionname@@YI******@Z”。
      注：“******”为函数返回值类型和参数类型表。（YG,YA,YI就是固有存在。）
      注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。
      注：C语言和C++语言间如果不进行特殊处理，也无法实现函数的互相调用。
##### 函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。（适用于c和c++）。因为这一般都是动态库，所以需要头文件的加入才知道有这个函数名，根据修饰方式才知道调用时候的链接方式，而函数定义的时候在头文件，在实现的时候在库的c/cpp文件，如果不同的话，估计是按照实现的时候的，或者编译不通过？，那么在用库的时候，寻找方式是定义的方式，但是库的实现的方式也就是说编译的库的寻找方式是实现的，那么不同就没法找到函数名以及函数指针，所以就无法实现调用库的函数调用，并且一定要注意的是只要是动态库，那么就一定有头文件，头文件只有函数定义，只有c/cpp文件才有函数实现，库的函数的实现与定义一定是分开的。
##### c语言和c++语言间如果不进行特殊处理，也无法实现函数的互相调用。因为c的abi通用，c++的不同编译器不通用，甚至不同版本也会有问题，并且c和c++的abi不通用，所以c和c++的dll无法进行混用，混用的唯一方式就是进行包装到处，比如c调用c++的库，就需要写个中间层进行包装用extern “C”，c++调用c的库倒是不用包装，因为在头文件里有按照c处理的extern “C”。计算机领域就是需要中间层，甚至到处都是中间层，尽管有部分损失，但是其实很小很小的，不影响，尤其是极大的提高了开发效率。
##### 计算机领域中处处都有中间层，到处都是中间层，计算机就是个从底层一步一步抽象来的工具，所以中间层非常重要，并且损失很小，最主要的是不要关注这些底层抽象的了，应该关注的是实际的应用以及和计算机不相关的某些方面，应该写中间层的，因为损失很小，但是开发效率很高。
          不要关注底层抽象的了，应该关注实际的应用以及和计算机不想管的某些方面，选择最合适的工具，不行就换工具，注意开发效率。
          选择最合适的工具做最合适的事情，不行就换工具，把关注点放在实际的应用上，忽略和实际的应用相关不大或者不相关的，注意开发效率。
